import pygame
import sys
import random
import math

# Инициализация Pygame
pygame.init()

# Объект шрифта
font = pygame.font.Font(None, 36)

# Размеры экрана
SCREEN_WIDTH, SCREEN_HEIGHT = 800, 600

# Цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)

# Игровые параметры
initial_player_radius = 20
player_radius = initial_player_radius
food_radius = 10
obstacle_size = 30
num_obstacles = 5

# Игрок
player_x = SCREEN_WIDTH // 2
player_y = SCREEN_HEIGHT // 2
player_color = RED

# Границы областей, где не должны появляться объекты
score_display_area = pygame.Rect(SCREEN_WIDTH - 150, 0, 200, 55)
record_display_area = pygame.Rect(SCREEN_WIDTH - 150, 40, 200, 55)

# Еда
food_x = random.randint(food_radius, SCREEN_WIDTH - food_radius)
food_y = random.randint(food_radius, SCREEN_HEIGHT - food_radius)
food_color = GREEN

# Препятствия (квадраты и треугольники)
obstacles = [
    {"type": "square", "x": random.randint(obstacle_size, SCREEN_WIDTH - obstacle_size),
     "y": random.randint(obstacle_size, SCREEN_HEIGHT - obstacle_size)}
    for _ in range(num_obstacles)
] + [
    {"type": "triangle", "x": random.randint(obstacle_size, SCREEN_WIDTH - obstacle_size),
     "y": random.randint(obstacle_size, SCREEN_HEIGHT - obstacle_size)}
    for _ in range(num_obstacles)
]

# Счетчик столкновений с едой
food_collision_count = 0

# Рекордное количество столкновений с едой
max_food_collision_count = 0

# Создание окна
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Einfach")

font = pygame.font.Font(None, 36)

def check_collision_circle(x1, y1, r1, x2, y2, r2):
    distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
    return distance < r1 + r2

def check_collision_square(x1, y1, s1, x2, y2, s2):
    return (
        x1 - s1 / 2 < x2 + s2 / 2 and
        x1 + s1 / 2 > x2 - s2 / 2 and
        y1 - s1 / 2 < y2 + s2 / 2 and
        y1 + s1 / 2 > y2 - s2 / 2
    )

def check_collision_triangle(x1, y1, s1, x2, y2, s2):
    return (
        x1 - s1 / 2 < x2 + s2 / 2 and
        x1 + s1 / 2 > x2 - s2 / 2 and
        y1 - s1 / 2 < y2 + s2 / 2 and
        y1 + s1 / 2 > y2 - s2 / 2
    )

# Функция для генерации новых координат препятствий
def generate_obstacles():
    return [
        {"type": "square", "x": random.randint(obstacle_size, SCREEN_WIDTH - obstacle_size),
         "y": random.randint(obstacle_size, SCREEN_HEIGHT - obstacle_size)}
        for _ in range(num_obstacles)
    ] + [
        {"type": "triangle", "x": random.randint(obstacle_size, SCREEN_WIDTH - obstacle_size),
         "y": random.randint(obstacle_size, SCREEN_HEIGHT - obstacle_size)}
        for _ in range(num_obstacles)
    ]

# Основной цикл игры
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    keys = pygame.key.get_pressed()
    player_x += (keys[pygame.K_RIGHT] - keys[pygame.K_LEFT]) * 5
    player_y += (keys[pygame.K_DOWN] - keys[pygame.K_UP]) * 5

    # Проверка столкновения с едой
    if check_collision_circle(player_x, player_y, player_radius, food_x, food_y, food_radius):
        # Если поглощена еда, генерируем новые координаты, проверяя, чтобы они не совпадали с препятствиями
        while True:
            food_x = random.randint(food_radius, SCREEN_WIDTH - food_radius)
            food_y = random.randint(food_radius, SCREEN_HEIGHT - food_radius)
            collision_with_obstacles = any(
                check_collision_circle(food_x, food_y, food_radius, obstacle["x"], obstacle["y"], obstacle_size + food_radius)
                for obstacle in obstacles
            )
            if not collision_with_obstacles and not score_display_area.colliderect(pygame.Rect(food_x - food_radius, food_y - food_radius, 2 * food_radius, 2 * food_radius)) and not record_display_area.colliderect(pygame.Rect(food_x - food_radius, food_y - food_radius, 2 * food_radius, 2 * food_radius)):
                # Увеличиваем счетчик столкновений с едой
                food_collision_count += 1
                # Обновляем рекорд, если текущий счет больше
                max_food_collision_count = max(max_food_collision_count, food_collision_count)
                # Увеличиваем радиус игрока
                player_radius += 2
                # Проверяем, достигнуто ли требуемое количество столкновений для изменения препятствий
                if food_collision_count % 3 == 0:
                    obstacles = generate_obstacles()
                break

    # Проверка столкновения с препятствиями
    for obstacle in obstacles:
        if obstacle["type"] == "square" and check_collision_square(
            player_x, player_y, player_radius * 2,
            obstacle["x"], obstacle["y"], obstacle_size
        ):
            # Если столкновение с квадратом, возвращаем радиус игрока к начальному значению
            player_radius = initial_player_radius
            player_x = random.randint(player_radius, SCREEN_WIDTH - player_radius)
            player_y = random.randint(player_radius, SCREEN_HEIGHT - player_radius)
            # Обнуляем счетчик столкновений с едой
            food_collision_count = 0
        elif obstacle["type"] == "triangle" and check_collision_triangle(
            player_x, player_y, player_radius * 2,
            obstacle["x"], obstacle["y"], obstacle_size
        ):
            # Если столкновение с треугольником, возвращаем радиус игрока к начальному значению
            player_radius = initial_player_radius
            player_x = random.randint(player_radius, SCREEN_WIDTH - player_radius)
            player_y = random.randint(player_radius, SCREEN_HEIGHT - player_radius)
            # Обнуляем счетчик столкновений с едой
            food_collision_count = 0

    # Отрисовка
    screen.fill((0, 0, 0))  # Заливка экрана черным цветом
    pygame.draw.circle(screen, player_color, (int(player_x), int(player_y)), player_radius)
    pygame.draw.circle(screen, food_color, (food_x, food_y), food_radius)
    for obstacle in obstacles:
        if obstacle["type"] == "square":
            pygame.draw.rect(
                screen, WHITE,
                pygame.Rect(obstacle["x"] - obstacle_size / 2, obstacle["y"] - obstacle_size / 2,
                            obstacle_size, obstacle_size)
            )
        elif obstacle["type"] == "triangle":
            pygame.draw.polygon(
                screen, WHITE,
                [(obstacle["x"] - obstacle_size / 2, obstacle["y"] + obstacle_size / 2),
                 (obstacle["x"], obstacle["y"] - obstacle_size / 2),
                 (obstacle["x"] + obstacle_size / 2, obstacle["y"] + obstacle_size / 2)],
                0  # Толщина границы треугольника
            )

    # Отрисовка фона для области "Счёт"
    pygame.draw.rect(screen, WHITE, score_display_area)
    # Отрисовка фона для области "Рекорд"
    pygame.draw.rect(screen, WHITE, record_display_area)

    # Отрисовка счетчика
    text = font.render(f'Счёт: {food_collision_count}', True, BLACK)
    screen.blit(text, (SCREEN_WIDTH - text.get_width() - 10, 10))

    # Отрисовка рекорда
    text_record = font.render(f'Рекорд: {max_food_collision_count}', True, BLACK)
    screen.blit(text_record, (SCREEN_WIDTH - text_record.get_width() - 10, 50))

    # Обновление экрана
    pygame.display.flip()

    # Задержка для контроля частоты обновления экрана
    pygame.time.Clock().tick(60)
